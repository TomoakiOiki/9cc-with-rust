# 座学
- 再帰下降構文解析をここまで実装してきて、同じようなコードを書いていることに気がつく
  - テンプレートやメタプログラミングでうまく生成できないか？
    - 最初からそういったことをすると高度に抽象化されたコードが出来上がり、自分以外の誰も読み解けない難解なコードが出来上がる
    - 「もっと良い書き方がありそうな単純なコード」くらいが丁度いい(し、テクニックでもある)
- 比較演算子のアセンブリ
  - `sete`命令
    - 直前の`cmp`命令で比較した2つの値が一緒だったら`AL`レジスタに1
    - そうでなければ0をセットする
      - `AL`レジスタ：`RAX`レジスタの下位8ビットの別称
  - `movzb`命令
    - `AL`を用いて`RAX`全体に0 or 1をセットしたい場合に上位56ビットを0クリアする命令
  - `setl`,`setle`,`setne`命令
    - 基本的には`sete`と同じ
    - `set larger`,`set lerger equal`,`set not equal`
### 分割コンパイル
- 1つのプログラムを複数のソースコードに分割して、別個にコンパイルすること
- 単体では実行不可能なプログラム断片を`オブジェクトファイル`という
- 最後に`オブジェクトファイル`をつなぎ合わせて1つの実行ファイルを作るプログラムを`リンカ`という
- なぜ分割しなきゃいけないのか？
  - 仮にリンカがない場合、標準ライブラリも毎回コンパイルする必要が出てくる
  - つまり、標準ライブラリなどは予めコンパイルしてできた`オブジェクトファイル`が配布されている
- 大きなプロジェクトだと数千万行のコードがあるので分割コンパイルをしないと現実的にビルドができなくなる

### ヘッダファイルの必要性
- 分割コンパイルをする場合、ここのCファイルにはコンパイルに必要な情報を入れておく必要がある
  - とはいえ全部を入れるとでかい
- 分割コンパイル時に呼び出し元の関数までコンパイルする必要はない
  - Call命令は生成されるが、飛び先を一旦仮置して、リンカが断片をくっつける際にリロケートする
- つまり関数本体の情報を省いたものを渡せば十分
  - 関数本体の情報を省いた関数を`宣言(declaration)`といい、省いてないものを`定義(definition)`という
  - 宣言だけを書いたファイルをヘッダーファイルといい、C言語では`#include "foo.h"`などでインポートすれば分割コンパイルには十分となる
  - おまじないとして習う`#include <stdio.h>`はそういうこと

### ワンパスコンパイラと前方宣言
- 1つのファイルに全部書く際も宣言が必要になるケースとして`コンパイラが先頭からしか読めない`
- その場合は`前方宣言`が必要になる

### リンクエラー
- 宣言だけあって、定義がないなどリンカが完全なプログラムを作成しようとした時にアドレスの修正ができないなど、
  - リンク時のエラーを`リンクエラー`という
  - 同じ変数、関数も同様



# 実装
- 比較演算子を含めた文法の実装
```
expr       = equality
equality   = relational ("==" relational | "!=" relational)*
relational = add ("<" add | "<=" add | ">" add | ">=" add)*
add        = mul ("+" mul | "-" mul)*
mul        = unary ("*" unary | "/" unary)*
unary      = ("+" | "-")? primary
primary    = num | "(" expr ")"
```
- 比較演算子を含めたアセンブリの出力
  - 下記テストパターンが通るようになった
```
0 => 0
42 => 42
5+20-4 => 21
 12 + 34 - 5  => 41
5+6*7 => 47
5*(9-6) => 15
(3+5)/2 => 4
-10+20 => 10
- -10 => 10
- - +10 => 10
0==1 => 0
42==42 => 1
0!=1 => 1
42!=42 => 0
0<1 => 1
1<1 => 0
2<1 => 0
0<=1 => 1
1<=1 => 1
2<=1 => 0
1>0 => 1
1>1 => 0
1>2 => 0
1>=0 => 1
1>=1 => 1
1>=2 => 0
```
  - `(3+4)*10>=2*(1+3)` こういうのも評価できるようになった生成されたアセンブリは以下(1が出力される)
```
.intel_syntax noprefix
.global main
main:
  push 2
  push 1
  push 3
  pop rdi
  pop rax
  add rax, rdi
  push rax
  pop rdi
  pop rax
  imul rax, rdi
  push rax
  push 3
  push 4
  pop rdi
  pop rax
  add rax, rdi
  push rax
  push 10
  pop rdi
  pop rax
  imul rax, rdi
  push rax
  pop rdi
  pop rax
  cmp rax, rdi
  setle al
  movzb rax, al
  push rax
  pop rax
  ret

```

# 感想
- ステップ7完了
- なんだかんだ座学も進めた
- 次回ファイル分割の章ぽいのでまた座学かも
