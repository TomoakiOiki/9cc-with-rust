# 座学
### グローバル変数の宣言と定義
- グローバル変数はアセンブリレベルだと関数とほぼ同じ
  - 宣言と定義の区別があるため、複数ファイルに変数の本体が存在するとリンクエラー
  - Cでは宣言時に0で初期化され、初期化式は定義にのみかける

### ステップ8 ファイル分割とMakefileの変更
- すでに分割しているので特にやることなし
- `9cc.h`というヘッダファイルを追加して、Makefileでリンクさせている
- Makefileの記述
  - `SRCS=$(wildcard *.c)`とし、
  - `OBJS=$(SRCS:.c=.c)`と書けば読み込まれた`.c`ファイルの拡張子を`.o`に置き換えた値を作れる

### ステップ9 1文字のローカル変数
- このステップの目標は下記をコンパイルできるようにすること
```
a = 3;
b = 5 * 6 - 8;
a + b / 2;
```
#### スタック上の変数領域
- Cの変数はメモリ上にあり、アドレスに対して名前を付けたものを変数と呼ぶ。
- ローカル変数は関数呼び出しごとに別々に存在するため決め打ちは不可
  - ローカル変数を関数呼び出しごとに別々に持たせるためにCではローカル変数をスタックに置く
- 具体例
  - a,bをローカル変数に持つ関数f
    - 関数呼び出しのcall命令でリターンアドレスをスタックに積む
    - a,bを定義し、RSPレジスタを２つすすめる(a,bは8バイトとする)
  - ![image](https://user-images.githubusercontent.com/76932511/161996021-0068c13b-c734-4844-8459-f4702b7de87a.png)
  - こうすることでRSP+8でa,RSPでbにそれぞれアクセスできる
  - このように関数呼び出しごとに確保されるメモリ領域を`関数フレーム`,`アクティベーションレコード`という
- 欠点
  - 9ccでは計算結果をスタックにpush/popしてるのでRSPの値が頻繁に書き換わるので、RSPからの固定オフセットで値にアクセスできない
  - 解決策
    - 関数フレームの開始位置を常に指すレジスタを追加する
      - `ベースレジスタ`という(x86では`RBP`レジスタを慣習的に使う)
- fが呼ばれた時
  - ![image](https://user-images.githubusercontent.com/76932511/161997914-8dfad91c-e9c1-44db-8a43-7d6bcfd54d1b.png)
  - `push rbp`をして、
  - ![image](https://user-images.githubusercontent.com/76932511/161998079-1a70a855-a808-404e-993e-9c0c27978033.png)
  - `mov rbp, rsp`をして、`sub rsp,16`すると
  - ![image](https://user-images.githubusercontent.com/76932511/161998236-25bef81c-169b-4aca-bc90-f8a272b5f65e.png)
- 関数からリターンする時
```
mov rsp, rbp
pop rbp
ret
```
- 関数の先頭で出力する定形の命令を`プロローグ`、末尾で出力する定形命令を`エピローグ`という

#### トーカナイザの変更
- 一旦小文字1文字で実装
- `a...z`であれば`IDENT`トークンを追加すれば良い

#### パーサの変更
- 文法を下記に変更
````
program    = stmt*
stmt       = expr ";"
expr       = assign
assign     = equality ("=" assign)?
equality   = relational ("==" relational | "!=" relational)*
relational = add ("<" add | "<=" add | ">" add | ">=" add)*
add        = mul ("+" mul | "-" mul)*
mul        = unary ("*" unary | "/" unary)*
unary      = ("+" | "-")? primary
primary    = num | ident | "(" expr ")"
````

#### 左辺と右辺
- 左辺は何でも良いわけではない
- Cにおいて左辺におけるのは基本的にメモリのアドレスを指す場合

#### 任意のアドレスから値をロードする方法
- `mov dst, [src]`
  - srcレジスタの値をアドレスとみなしてそこの値をdstに保存
- `mov [dst], src`
  - dstレジスタの値をアドレスとみなしてそこの値をsrcに保存
- `pop rax`と以下は同値
```
mov rax, [rsp]
add rsp, 8
```
- `push rax`と以下は同値
```
sub rsp, 8
mov [rsp], rax
```
# 実装
- ローカル変数関連のトーカナイザ、パーサー、アセンブリ生成の実装
  - 途中
# 感想
- ついにプログラムらしいものをコンパイルできる状態が見えてきた
- 当分の目標は関数とローカル変数を正しくコンパイルできるようにする事になりそう
