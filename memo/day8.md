# 座学
#### BNFの続きから
  - `A = a_1`と`A = a_2`とあるときはどっちで展開しても良い
  - 生成規則の右辺は空でも良い(空を`ε`を使う)
  - 文字列はダブルクォートで囲う
    - 文字列は常に終端記号
  - EBNF
    - BNFに以下のルールを追加したもの
      - `A*`: Aの0回以上繰り返し
      - `A?`: A or ε
      - `A | B`: A or B
      - `(...)`: グループ化
      - 例: `("fizz" | "buzz")*`
    - EBNFはBNFでも表現できる
      - `A = a*` → `A = aA と A = ε`
      - `A = a?` → `A = a と A = ε`
      - `A = a | b` → `A = a と A = b`
      - `A = a (b_1 b_2...) c` → `A = aBc と B = b_1 b_2...`
#### 単純な生成規則
- 加減の生成規則
  - `expr = num ("+" num | "-" num)*`
```
expr → num → "1"

expr → num "+" num
     → "10" "+" "5"

expr → num "-" num "+" num
     → "42" "-" "30" "+" "2"
``` 
  - 入力に含まれるすべてのトークンを含んだ、文法に1対1でマッチした構文木を`具象構文木`という
  - EBNFでは文法は表現しても、計算順序などのルールは表現できない
    - 厳密にはEBNFでそこまで表現できるが、それによって定義される文法が複雑になりすぎてしまい、パーサーがうまく書けなくなるらしい
    - なので、文法としての厳密さと自然言語による補足のバランスが重要
#### 生成規則による演算子の優先順位の表現
- 下記のように先にmulというルールを入れてあげる
  - こうすることで木構造が1層深くなり、優先順位を表現できる
```
expr = mul ("+" mul | "-" mul)*
mul  = num ("*" num | "/" num)*
```
![image](https://user-images.githubusercontent.com/76932511/160813760-04d2f4e1-854d-4c91-a713-4fb078eb0d5c.png)
#### 再帰的な生成規則
- exprの子が更にexprを持つパターン
```
expr    = mul ("+" mul | "-" mul)*
mul     = primary ("*" primary | "/" primary)*
primary = num | "(" expr ")"
```
![image](https://user-images.githubusercontent.com/76932511/160813373-d5535457-8b83-4fbc-933f-356f68f07d90.png)
#### 再帰下降構文解析
- コンパイラがやりたいことは入力（プログラム）と同じ文字列を表現する構文木の構造を知ること
  - 再帰下降構文解析は規則から文にマッチする構文木を機械的に書くテクニック
- 基本戦略
  - 非終端記号を１つずつ関数にマッピングしていく
    - 上の例だと`expr,mul,primary`の3つの関数ができる
  - それぞれの関数はトークン列をパースする
  - というわけで実装に続く
# 実装
- 再帰下降構文解析の実装
- 全体的なリファクタ
  - `Peekable<IntoIter<Token>>`を主体にループを回すように変更
# 感想
- a
